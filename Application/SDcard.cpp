/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug 18 2014, 17:12:05                              *
*        (c) 2014 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END
	#include <LPC17xx.h>
	#include <RTL.h>
	
	#include <stdio.h>
#include <ctype.h>

	#include <stdio.h>
	#include <string.h>
	#include <stdint.h>
	#include "..\FS\FS.h"
#include "DIALOG.h"
#include "MESSAGEBOX.h"

#include "..\AF_UART_LIB\AF_CPU.h"

#ifndef _MAX_PATH
  #define _MAX_PATH 256
#else
  #if (_MAX_PATH > 256)
    #undef  _MAX_PATH
    #define _MAX_PATH 256
  #endif
#endif

#ifndef _MAX_EXT
  #define _MAX_EXT  256
#endif

WM_HWIN CreateEditor(char* str);
/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

static struct {
  U32 Mask;
  char c;
} _aAttrib[] = {

  { FS_ATTR_READ_ONLY, 'R' },
  { FS_ATTR_HIDDEN   , 'H' },
  { FS_ATTR_SYSTEM   , 'S' },
  { FS_ATTR_DIRECTORY, 'D' },
  { FS_ATTR_ARCHIVE  , 'A' },

};

// USER START (Optionally insert additional static data)
// USER END


/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _GetExt
*/
static void _GetExt(char * pFile, char * pExt) {
  int Len;
  int i;
  int j;

  //
  // Search beginning of extension
  //
  Len = strlen(pFile);
  for (i = Len; i > 0; i--) {
    if (*(pFile + i) == '.') {
      *(pFile + i) = '\0';     // Cut extension from filename
      break;
    }
  }
  //
  // Copy extension
  //
  j = 0;
	if (i>2){
  while (*(pFile + ++i) != '\0') {
    *(pExt + j) = *(pFile + i);
    j++;
  }
  *(pExt + j) = '\0';          // Set end of string
}
	else 
		*pExt='\0';
}

static void _iGetExt2 (char * pFile, char * pExt) {
  int Len;
  int i;
  int j;

  //
  // Search beginning of extension
  //
  Len = strlen(pFile);
  for (i = Len; i > 0; i--) {
    if (*(pFile + i) == '.') 
      break; 
  }
  //
  // Copy extension
  //
  j = 0;
	if (i>2){
  while (*(pFile + ++i) != '\0') {
    *(pExt + j) = *(pFile + i);
    j++;
  }
  *(pExt + j) = '\0';          // Set end of string
}
	else 
		*pExt='\0';
}


/*********************************************************************
*
*       _GetData
*/
static int _GetData(CHOOSEFILE_INFO * pInfo) {

	static FINFO info;
  static char         acFile  [40];
  static char         acExt   [5];
  static char         acAttrib[6]         = { 0 };
  char                c;
  int                 i;
  int                 r;
	static char Addr[50];
	
  switch (pInfo->Cmd) {
  case CHOOSEFILE_FINDFIRST:
	sprintf(Addr,"%s*.*",pInfo->pRoot);
		info.fileID=0;
		r =ffind(Addr,&info);
  //  r = FS_FindFirstFile(&FindData, pInfo->pRoot, acFile, sizeof(acFile));
    break;
  case CHOOSEFILE_FINDNEXT:
		r =ffind(Addr,&info);
   // r = FS_FindNextFile(&FindData) ^ 1;
    break;
  }
  if (r == 0) {
    pInfo->Flags = (info.attrib & _aAttrib[3].Mask) ? CHOOSEFILE_FLAG_DIRECTORY : 0;
    for (i = 0; i < GUI_COUNTOF(_aAttrib); i++) {
      if (info.attrib & _aAttrib[i].Mask) {
        c = _aAttrib[i].c;
      } else {
        c = '-';
      }
      acAttrib[i] = c;
    }
		
		strcpy(acFile,(char *)info.name);
    _GetExt(acFile, acExt);
		
		if(!(info.attrib & FS_ATTR_DIRECTORY))	 // if not directory add format
    pInfo->pExt    = acExt;

		else // if it is directory format null
			    pInfo->pExt    =(char*)'\0';
		
		pInfo->pAttrib = acAttrib;
    pInfo->pName   = acFile;
    pInfo->SizeL   = info.size;
    pInfo->SizeH   = 0;
		
  }
  return r;

}


/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
unsigned int LengthWAV;
FILE *Mfile;
long dataWAV;

#ifdef __cplusplus
extern "C" {
#endif
void TIMER0_IRQHandler(void) {
long  val=0;
		
 //	if (LengthWAV==8)
		val=((fgetc(Mfile)&0xff)<<5); 
			
/*	if (LengthWAV>=16){
		val =(fgetc(Mfile)&0xff);
		val|=(fgetc(Mfile)&0xff)<<8;
	}
*/
		val  += 0x8000;                         /* Add Bias */
   // val  &= 0xFFFF;                         /* Mask Value */
						
		LPC_DAC->DACR = val & 0xFFC0;
				
				if ((feof(Mfile))){
						GUI_Delay(900);
						rewind(Mfile);
					}
				
	LPC_TIM0->IR = 1;
	
}
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
void TIMER2_IRQHandler(void) {
	
  	dataWAV =(fgetc(Mfile)&0xff);
//	if (LengthWAV>=16)
		dataWAV|=(fgetc(Mfile)&0xff)<<8; 	
	//LPC_GPIO2->FIOPIN0=1;
	LPC_TIM2->IR = 1;
	
}
#ifdef __cplusplus
}
#endif

		 
void toups_func (char *ch,int num)
{
	for (int i=0;i<num;i++)
	toupper(ch[i]);	
}

/*********************************************************************
*
*       CreateSDcard
*/
WM_HWIN CreateSDcard(void);
WM_HWIN CreateSDcard(void) {
  WM_HWIN hWin;
	
		
//	const char        acMask[]            = "*.*";
  CHOOSEFILE_INFO   Info                = { 0 };
  uint16_t               xSize;
  uint16_t               ySize;
  uint8_t               r;
  char              acDir[]    = "M:";
  char const      * apDrives[1]         = { acDir };
  // USER START (Optionally insert additional variables)
  // USER END

		finit ("M0");
  WM_SetCreateFlags(WM_CF_MEMDEV);
  WM_SetDesktopColor(GUI_WHITE);
  //
  // Set defaults for FRAMEWIN widget
  //
  FRAMEWIN_SetDefaultFont(GUI_FONT_20_ASCII);
  FRAMEWIN_SetDefaultTextAlign(GUI_TA_HCENTER);
  //
  // Get display size and initialize pointers to search mask and callback routine
  //
  xSize = LCD_GetXSize();
  ySize = LCD_GetYSize();
  Info.pfGetData = _GetData;
  Info.pMask     = "*";
	CHOOSEFILE_SetTopMode(1);
	static char         format   [5];
	 _start:
    
    hWin = CHOOSEFILE_Create(WM_HBKWIN, 10, 15, xSize-10, ySize-15, apDrives, GUI_COUNTOF(apDrives), 0, "File", 0, &Info);

    r = GUI_ExecCreatedDialog(hWin);
   if (r == 0) {
		  _iGetExt2 (Info.pRoot,format);
			toups_func(format,3);
			
		 
			if (!(strncmp(format,"TXT",3))){ //--------------------------TXT---------------------------
		  	FILE *Tfile;
				Tfile=fopen(Info.pRoot,"r");
				uint32_t counter=0;
				char ch;
				do{
					ch=fgetc(Tfile);
					counter++;
				}while(ch!=EOF);
				rewind(Tfile);
				
				char Tstr[counter];
				
			for(uint32_t i=0 ; i<counter ; i++)
				Tstr[i]=fgetc(Tfile);

				fclose(Tfile);
				CreateEditor(Tstr);
			}
			

			else if (!(strncmp(format,"wav",3))){ //--------------------------WAV---------------------------
				Mfile=fopen(Info.pRoot,"r");
				LPC_PINCON -> PINSEL1|=0X00200000; // P0.26 IS DAC OUTPUT
				
				char headerWAV[45];
					fgets(headerWAV,44,Mfile);
				fgetc(Mfile);	
			//	rewind(Mfile);
				// Get Sample Rate From Header File of WAV file
				unsigned int Srate=headerWAV[24]|((headerWAV[25])<<8)|((headerWAV[26])<<16)|((headerWAV[27])<<24);
				LengthWAV=headerWAV[16]|((headerWAV[17])<<8)|((headerWAV[18])<<16)|((headerWAV[19])<<24);
				CPU cpuclk;
				
				
				LPC_TIM0->MR0 = cpuclk.GetCpuClk()/4/Srate - 1;	// TC0 Match Value 0 
				LPC_TIM0->MCR = 3;					// TCO Interrupt and Reset on MR0 
				LPC_TIM0->TCR = 1;					// TC0 Enable 
				NVIC_EnableIRQ(TIMER0_IRQn);
				
			/*	LPC_SC->PCONP|=1<<22;
				LPC_TIM2->MR0 = cpuclk.GetCpuClk()/4/Srate - 1-150;	// TC0 Match Value 0 
				LPC_TIM2->MCR = 3;					// TCO Interrupt and Reset on MR0 
				LPC_TIM2->TCR = 1;					// TC0 Enable 
				NVIC_EnableIRQ(TIMER2_IRQn);
				*/
				LPC_GPIO2->FIOPIN0=Srate/1000;

		}
	}


  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
